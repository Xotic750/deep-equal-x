{"version":3,"sources":["../src/deep-equal-x.js"],"names":[],"mappings":"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","file":"deep-equal-x.esm.js","sourcesContent":["import isDate from 'is-date-object';\nimport isArguments from 'is-arguments';\nimport isPrimitive from 'is-primitive-x';\nimport isObject from 'is-object';\nimport isBuffer from 'is-buffer';\nimport isString from 'is-string';\nimport isError from 'is-error-x';\nimport isMap from 'is-map-x';\nimport isSet from 'is-set-x';\nimport isNil from 'is-nil-x';\nimport isRegExp from 'is-regexp-x';\nimport indexOf from 'index-of-x';\nimport slice from 'array-slice-x';\nimport some from 'array-some-x';\nimport filter from 'array-filter-x';\nimport sort from 'stable';\nimport $keys from 'object-keys-x';\nimport $getPrototypeOf from 'get-prototype-of-x';\nimport hasBoxedString from 'has-boxed-string-x';\nimport toBoolean from 'to-boolean-x';\n\n// Check failure of by-index access of string characters (IE < 9)\n// and failure of `0 in boxedString` (Rhino)\nconst hasBoxedStringBug = hasBoxedString === false;\n// Used to detect unsigned integer values.\nconst reIsUint = /^(?:0|[1-9]\\d*)$/;\n/* eslint-disable-next-line compat/compat */\nconst hasMapEnumerables = typeof Map === 'function' ? $keys(new Map()) : [];\n/* eslint-disable-next-line compat/compat */\nconst hasSetEnumerables = typeof Set === 'function' ? $keys(new Set()) : [];\nlet hasErrorEnumerables;\n\ntry {\n  // noinspection ExceptionCaughtLocallyJS\n  throw new Error('a');\n} catch (e) {\n  hasErrorEnumerables = $keys(e);\n}\n\nconst indexNotFound = -1;\nconst maxSafeIndex = 4294967295; // (2^32)-1\n\n/**\n * Checks if `value` is a valid string index. Specifically for boxed string\n * bug fix and not general purpose.\n *\n * @private\n * @param {*} value - The value to check.\n * @returns {boolean} Returns `true` if `value` is valid index, else `false`.\n */\nconst isIndex = function isIndex(value) {\n  let num = indexNotFound;\n\n  if (reIsUint.test(value)) {\n    num = Number(value);\n  }\n\n  return num > indexNotFound && num % 1 === 0 && num < maxSafeIndex;\n};\n\n// eslint-disable jsdoc/require-param\n// noinspection JSCommentMatchesSignature\n/**\n * Get an object's key avoiding boxed string bug. Specifically for boxed\n * string bug fix and not general purpose.\n *\n * @private\n * @param {Array|string|object} object - The object to get the `value` from.\n * @param {string|number} key - The `key` reference to the `value`.\n * @param {boolean} isStr - Is the object a string.\n * @param {boolean} isIdx - Is the `key` a character index.\n * @returns {*} Returns the `value` referenced by the `key`.\n */\n// eslint-enable jsdoc/require-param\nconst getItem = function getItem(args) {\n  const [object, key, isStr, isIdx] = args;\n\n  return isStr && isIdx ? object.charAt(key) : object[key];\n};\n\n/**\n * Filter `keys` of unwanted Error enumerables. Specifically for Error has\n * unwanted enumerables fix and not general purpose.\n *\n * @private\n * @param {Array} keys - The Error object's keys.\n * @param {Array} unwanted - The unwanted keys.\n * @returns {Array} Returns the filtered keys.\n */\nconst filterUnwanted = function filterUnwanted(keys, unwanted) {\n  return unwanted.length\n    ? filter(keys, function predicate(key) {\n        return indexOf(unwanted, key) === indexNotFound;\n      })\n    : keys;\n};\n\n// eslint-disable jsdoc/require-param\n// noinspection JSCommentMatchesSignature\n/**\n * Tests for deep equality. Primitive values are compared with the equal\n * comparison operator ( == ). This only considers enumerable properties.\n * It does not test object prototypes, attached symbols, or non-enumerable\n * properties. This can lead to some potentially surprising results. If\n * `strict` is `true` then Primitive values are compared with the strict\n * equal comparison operator ( === ).\n *\n * @private\n * @param {*} actual - First comparison object.\n * @param {*} expected - Second comparison object.\n * @param {boolean} [strict] - Comparison mode. If set to `true` use `===`.\n * @param {object} previousStack - The circular stack.\n * @returns {boolean} `true` if `actual` and `expected` are deemed equal,\n *  otherwise `false`.\n */\n// eslint-enable jsdoc/require-param\nconst baseDeepEqual = function baseDeepEqual(args) {\n  const [actual, expected, strict, previousStack] = args;\n\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  }\n\n  if (isBuffer(actual) && isBuffer(expected)) {\n    return (\n      actual.length === expected.length &&\n      some(actual, function predicate(item, index) {\n        return item !== expected[index];\n      }) === false\n    );\n  }\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  if (isDate(actual) && isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n  }\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same `source` and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase` & `sticky`).\n  if (isRegExp(actual) && isRegExp(expected)) {\n    return actual.toString() === expected.toString() && actual.lastIndex === expected.lastIndex;\n  }\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by == or strict ===.\n  if (isObject(actual) === false && isObject(expected) === false) {\n    if (strict) {\n      return actual === expected;\n    }\n\n    // noinspection EqualityComparisonWithCoercionJS\n    return actual == expected; /* eslint-disable-line eqeqeq */\n  }\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  if (isNil(actual) || isNil(expected)) {\n    return false;\n  }\n\n  /* jshint eqnull:false */\n  // This only considers enumerable properties. It does not test object\n  // prototypes, attached symbols, or non-enumerable properties. This can\n  // lead to some potentially surprising results.\n  if (strict && $getPrototypeOf(actual) !== $getPrototypeOf(expected)) {\n    return false;\n  }\n\n  // if one is actual primitive, the other must be same\n  if (isPrimitive(actual) || isPrimitive(expected)) {\n    return actual === expected;\n  }\n\n  let ka = isArguments(actual);\n  let kb = isArguments(expected);\n  const aNotB = ka && kb === false;\n  const bNotA = ka === false && kb;\n\n  if (aNotB || bNotA) {\n    return false;\n  }\n\n  if (ka) {\n    if (ka.length !== kb.length) {\n      return false;\n    }\n\n    return baseDeepEqual([slice(actual), slice(expected), strict, null]);\n  }\n\n  ka = $keys(actual);\n  kb = $keys(expected);\n\n  // having the same number of owned properties (keys incorporates hasOwnProperty)\n  if (ka.length !== kb.length) {\n    return false;\n  }\n\n  if (isObject(actual)) {\n    if (isError(actual)) {\n      ka = filterUnwanted(ka, hasErrorEnumerables);\n    } else if (isMap(actual)) {\n      ka = filterUnwanted(ka, hasMapEnumerables);\n    } else if (isSet(actual)) {\n      ka = filterUnwanted(ka, hasSetEnumerables);\n    }\n  }\n\n  if (isObject(expected)) {\n    if (isError(expected)) {\n      kb = filterUnwanted(kb, hasErrorEnumerables);\n    } else if (isMap(expected)) {\n      kb = filterUnwanted(kb, hasMapEnumerables);\n    } else if (isSet(expected)) {\n      kb = filterUnwanted(kb, hasSetEnumerables);\n    }\n  }\n\n  // the same set of keys (although not necessarily the same order),\n  sort.inplace(ka);\n  sort.inplace(kb);\n  let aIsString;\n  let bIsString;\n\n  if (hasBoxedStringBug) {\n    aIsString = isString(actual);\n    bIsString = isString(expected);\n  }\n\n  // ~~~cheap key test\n  // equivalent values for every corresponding key, and\n  // ~~~possibly expensive deep test\n  return (\n    some(ka, function predicate(key, index) {\n      if (key !== kb[index]) {\n        return true;\n      }\n\n      const isIdx = (aIsString || bIsString) && isIndex(key);\n      const stack = previousStack || [actual];\n      const item = getItem([actual, key, aIsString, isIdx]);\n      const isPrim = isPrimitive(item);\n\n      if (isPrim === false) {\n        if (indexOf(stack, item) !== indexNotFound) {\n          throw new RangeError('Circular object');\n        }\n\n        stack.push(item);\n      }\n\n      const result = baseDeepEqual([item, getItem([expected, key, bIsString, isIdx]), strict, stack]) === false;\n\n      if (isPrim === false) {\n        stack.pop();\n      }\n\n      return result;\n    }) === false\n  );\n};\n\n// eslint-enable jsdoc/require-param\n// noinspection JSCommentMatchesSignature\n/**\n * Tests for deep equality. Primitive values are compared with the equal\n * comparison operator ( == ). This only considers enumerable properties.\n * It does not test object prototypes, attached symbols, or non-enumerable\n * properties. This can lead to some potentially surprising results. If\n * `strict` is `true` then Primitive values are compared with the strict\n * equal comparison operator ( === ).\n *\n * @param {*} actual - First comparison object.\n * @param {*} expected - Second comparison object.\n * @param {boolean} [strict] - Comparison mode. If set to `true` use `===`.\n * @returns {boolean} `true` if `actual` and `expected` are deemed equal,\n *  otherwise `false`.\n * @see https://nodejs.org/api/assert.html\n */\n// eslint-disable jsdoc/require-param\nconst deepEqual = function deepEqual(actual, expected) {\n  /* eslint-disable-next-line prefer-rest-params */\n  return baseDeepEqual([actual, expected, toBoolean(arguments[2])]);\n};\n\nexport default deepEqual;\n"]}